# Лабораторная работа №2
Простейшие алгоритмы сопоставления изображений
---

## Теоретическая база

### **Прямой поиск шаблона (Template Matching)**

Template Matching — это классический метод компьютерного зрения, который основывается на корреляции. Суть метода заключается в том, чтобы перемещать шаблон по изображению и вычислять степень соответствия (сходства) между шаблоном и соответствующей частью изображения.

#### **Метрики сходства:**

- **Нормализованная корреляция (Normalized Cross-Correlation, NCC):**

$NCC = \frac{\sum_{i,j} (T_{i,j} \cdot I_{x+i, y+j})}{\sqrt{\sum_{i,j} T_{i,j}^2 \cdot \sum_{i,j} I_{x+i, y+j}^2}}$ где T — шаблон, I — изображение, x, y — координаты блока.
- **Сумма квадратов разностей (Sum of Squared Differences, SSD):**

$SSD = \sum_{i,j} (T_{i,j} - I_{x+i, y+j})^2$

И др. (методов много (6))
### **Поиск ключевых точек**

Ключевые точки (feature points) — это особые, легко узнаваемые участки изображения, такие как углы, края, пересечения. Поиск с использованием ключевых точек позволяет сопоставлять изображения, которые могут быть подвергнуты масштабированию, повороту, изменению перспективы и освещения.
## Описание разработанной системы

Использовались методы из OpenCV. Для Template Matching 
используется cv2.matchTemplate с методом `cv.TM_CCOEFF` 
[[1](https://blog.roboflow.com/template-matching)].
Из результата берем минимальное значение и это будет вершиной наиболее подходящей области.

Для ключевых точек используется SIFT - cv.SIFT_create(). 
А также после получения ключевых точек двух изображений, 
они связываются при помощи cv.BFMatcher. По связям можно 
увидеть насколько хорошо нашелся фрагмент.

Также стоит обратить внимание, что в обоих случаях работа ведется с 
черно-белыми изображениями.
## Результаты работы и тестирования системы

[Jupyter с результатами методов](main.ipynb)

Оба метода были протестированы на двух изображениях с 5 фрагментами для каждого. 
В изображении со столом с едой, 4 фрагмента взяты с изображения и 1 это курица из другого источника (есть похожая на изображении)
В итоге ни sift, ни matcher не смогли найти другую жареную курицу. С чистыми фрагментами справились отлично.

У изображения стола с предметами, 3 фрагмента это ноутбук, отзеркаленный по вертикали и горизонтали. Все три варианта хорошо нашлись на фотографии.
Также были фрагменты растения и бумажек, которых несколько на столе. Но и matcher, и sift нашли только один, изначальный экземпляр.

## Выводы по работе

В результате работы были реализованы два варианта нахождения части изображения на исходном: с помощью функции match_template и с помощью SIFT. 
Template Matcher хорошо находил фрагменты, на которые мало влияет пространственные искажения. SIFT выделял подобие признаков и старался работать с ними. 

| Количество верно найденных изображений | matchTemplate | SIFT  |
|:---------------------------------------|---------------|-------|
| Вырезаны из исходного                  | 6/6           | 5,5/6 | 
| Сфотографированы с другого ракурса     | 3/4           | 2/4   |

## Источники

* [Template Matching документация OpenCV](https://docs.opencv.org/3.4/d4/dc6/tutorial_py_template_matching.html)
* [SIFT using OpenCV](https://thepythoncode.com/article/sift-feature-extraction-using-opencv-in-python)
* [Описание как работает SIFT](https://blog.roboflow.com/sift/)
* [[1](https://blog.roboflow.com/template-matching)]